- **了解文件`IO`，`Sockete`编程，进程线程模型，`IPC`机制**

- 文件`IO`
  > - 虚拟地址空间（进程地址空间分区）：隔离风险，避免交换开销
  >
  > - 文件描述符、文件描述符表（内核->`PCB`->文件描述符表）、标准输出、输入、错误
  >
  > - `open`、`close`、`read`、`write`、`lseek`、`truncate`、`ftruncate`、`perror`
  >
  > - `flags`：`O_RDONLY`、`O_WRONLY`、`O_RDWR`、`O_APPEND`、`O_CREAT`、`O_EXCL`
  >
  > - 将一个文件的内容写入另一个文件
  >
  >   ```c
  >   while((len = read(fd1, buf, sizeof(buf))) > 0)
  >   {
  >       write(fd2, buf, len);
  >   }
  >   ```
  >
  > - 文件位置：`SEEK_SET`、`SEEK_CUR`、`SEEK_END`
  >
  > - `file`（编码属性等）、`stat`（文件系统属性）、`lstat`（软链接关联文件属性）
  >
  > - `stat(const char *pathname, struct stat *buf);`(`buf`作为传出参数，记录了信息（`inode`、`st_mode`）)
  >
  > - 宏函数判断文件类型：`S_ISREG(myst.st_mode)`、`S_ISDIR(myst.st_mode)`)、判断权限
  >
  > - 文件描述符复制`dup`、重定向`dup2`、**文件描述符复制、获取、设置属性`fcntl(int fd, int cmd, ...)`**
  >
  > - ```c
  >   // 得到文件的flag属性
  >   int flag = fcntl(fd, F_GETFL);
  >   // 添加新的flag 标志
  >   flag = flag | O_APPEND;
  >   // 将更新后的falg设置给文件
  >   fcntl(fd, F_SETFL, flag);
  >   ```
  >
  > - 目录三剑客`opendir`、`readdir`、`closedir`、`scandir`（只遍历指定目录，不递归子目录）
  >
  > - `int scandir(const char *dirp, struct dirent ***namelist, int (*filter)(const struct dirent *), int (*compar)(const struct dirent **, const struct dirent **));`(第二个参数是**三级指针**（指针数组），后两个参数是函数指针，用于过滤、文件排序（`alphasort`文件名排序，`versionsort`版本排序）)
  >
  > - 遍历目录中的文件
  >
  >   ```c
  >   DIR* dir = opendir("/path");
  >   struct dirent* ptr = NULL;
  >   while((ptr = readdir(dir)) != NULL) {}
  >   int ret = closedir(dir);
  >   ```
  >
  > - `Linux`的文件类型（普通文件、软链接文件、目录文件、块设备、字符设备、管道、`socket`本地套接字）
  
- `Socket`编程
  1. `socket`基本流程（`TCP`、`UDP`）
  2. 地址结构
  3. 常用选项
  4. 非阻塞与多路复用
  5. `TCP`粘包与拆包问题
  
- 进程与线程模型
  1. 创建与管理
  2. 进程属性
  3. 进程间关系
  4. 线程
  
  > - 进程（动态，消耗内存，`CPU`资源，拥有虚拟地址空间）和程序（静态、磁盘可执行文件）
  >
  > - 并行和并发
  >
  > - `PCB`的实质（`task_struct`结构体），包含内容（`PID`、状态、虚拟地址空间信息、终端信息、掩码、文件描述符表、信号、分组`ID`、会话、进城组等等）
  >
  > - ```c
  >   pid_t getpid(void);
  >   pid_t getppid(void);
  >   pid_t fork(void);// 拷贝后父子进程的地址空间中用户区相同，文件描述符表也会拷贝
  >   /* 区别：
  >   	父子进程各自虚拟地址空间相互独立
  >   	代码段虽然相同，但是后续执行的逻辑可能不同
  >   	全局数据区、堆、内存映射区（动态库加载区）、栈数据会各自发生变化
  >   	内核区中存储的父子进程ID不同
  >   */
  >   int execl(const char *path, const char *arg, ...);	// 路径 进程名 参数
  >   int execlp(const char *file, const char *arg, ...); // 文件 进程名 参数 p is path
  >   // exec族函数并没有创建新进程的能力，只是让启动的新进程寄生到自己虚拟地址空间之内，并挖空了自己的地址空间用户区，把新启动的进程数据填充进去。
  >   ```
  >
  > - ```c
  >   void exit(int status);	// 和 return 的区别
  >   ```
  >
  > - 孤儿进程（父进程退出，由`init`进程接管，内核区的`PCB`无法自己释放）与僵尸进程（父进程不管理已经退出的子进程的资源）
  >
  > - 进程回收（阻塞`wait`（单次回收），非阻塞`waitpid`（指定回收的`pid`和方式）），都具有传出参数
  >
  > - 管道的实质（独立于进程，是内核的一块内存（内核缓冲区），结构：环形队列，阻塞式）
  >
  > - 匿名管道（`pipe`，有血缘关系的`IPC`）、命名管道（名字存在于文件系统，`fifo`，`mkfifo`函数或命令，需要`open`得到`fd`），用于进程间通信，可用`fcntl`获取、修改`fd`的属性
  
- `IPC`进程间通信机制
  1. 管道
  2. 信号
  3. 消息队列
  4. 共享内存
  5. 信号量
  6. 套接字`IPC`