1. `xv6`是什么内核架构

   > 宏内核：将进程管理、文件管理、设备驱动、内存管理等都在一个内核空间中实现，`UNIX`常用，模块之间调用简单效率高，但内核代码庞大，一个模块出错可能会影响整个系统崩溃
   >
   > 微内核：将内核功能尽量精简，只保留最基础的部分（进程间通信、调度、内存管理等），其他服务都在用户态进程中，通过消息传递与内核交互，稳定性和拓展性较好，但用户态和内核态切换频繁，性能开销

2. `xv6`的内核源码

   > - 启动与内核初始化
   >
   >   > **`entry.S`**：内核入口（从汇编开始执行），设置栈、跳转到 `main`。
   >   >
   >   > **`start.c`**：内核 C 语言的第一个入口（`main`），负责初始化内核子系统。
   >   >
   >   > **`kernel.ld`**：链接脚本，定义内核在内存中的布局。
   >   >
   >   > **`trampoline.S`**：用户态和内核态切换时的“跳板”代码（切换页表）。
   >   >
   >   > **`kernelvec.S`**：内核的 trap 向量表（中断/异常的入口）。
   >
   > - 进程与调度
   >
   >   > **`proc.c / proc.h`**：进程管理（`fork`, `exit`, `scheduler`, PCB `struct proc`）。
   >   >
   >   > **`swtch.S`**：上下文切换（保存/恢复寄存器）。
   >   >
   >   > **`sysproc.c`**：与进程相关的系统调用实现（`getpid`, `fork`, `exit` 等）。
   >
   > - 内存管理
   >
   >   > **`vm.c`**：虚拟内存管理（页表、映射、页分配）。
   >   >
   >   > **`vmcopyin.c`**：用户态到内核态安全拷贝数据的辅助函数。
   >   >
   >   > **`kalloc.c`**：物理内存分配器（基于空闲链表）。
   >
   > - 系统调用与中断
   >
   >   > **`syscall.c / syscall.h`**：系统调用分发（从系统调用号到函数指针）。
   >   >
   >   > **`sysfile.c`**：与文件系统相关的系统调用（`open`, `read`, `write` 等）。
   >   >
   >   > **`sysproc.c`**：进程相关的系统调用。
   >   >
   >   > **`trap.c`**：中断/异常处理。
   >   >
   >   > **`defs.h`**：函数声明（避免循环依赖）。
   >
   > - 文件系统与`IO`
   >
   >   > **`fs.c / fs.h`**：文件系统核心（`inode`、目录、超级块）。
   >   >
   >   > **`file.c / file.h`**：文件描述符层（管理 `struct file`，抽象设备和普通文件）。
   >   >
   >   > **`log.c`**：日志（写时复制日志，保证文件系统一致性）。
   >   >
   >   > **`bio.c / buf.h`**：缓冲区缓存（block cache，管理磁盘块缓冲）。
   >   >
   >   > **`pipe.c`**：管道实现（进程间通信）。
   >   >
   >   > **`sleeplock.c / sleeplock.h`**：睡眠锁，用于文件系统。
   >   >
   >   > **`spinlock.c / spinlock.h`**：自旋锁。
   >
   > - 设备驱动
   >
   >   > **`uart.c`**：UART 串口驱动（控制台输入输出）。
   >   >
   >   > **`virtio_disk.c / virtio.h`**：VirtIO 磁盘驱动（QEMU 模拟磁盘）。
   >   >
   >   > **`ramdisk.c`**：RAM 磁盘驱动（实验用）。
   >   >
   >   > **`plic.c`**：中断控制器 PLIC 驱动。
   >   >
   >   > **`console.c`**：控制台设备（用 UART 实现）。

3. `xv6`的启动流程

   > ```markdown
   > 上电 / 复位
   >    ↓
   > M 模式 (OpenSBI)
   >    - 初始化硬件
   >    - 进入 S 模式
   >    ↓
   > S 模式 (xv6 内核)
   >    entry.S → start.c → main()
   >    - 初始化子系统 (内存/进程/文件系统/驱动)
   >    - 创建第一个用户进程 init
   >    ↓
   > U 模式
   >    initcode.S (调用 exec("/init"))
   >    ↓
   > 运行 /init
   >    - 启动 shell (sh)
   >    ↓
   > 用户可以输入命令
   > ```
   >
   > **硬件上电 → 进入 M 模式 (Machine mode)**
   >
   > - `RISC-V`上电时，会初始化自己，运行一个存储在只读内存中的引导加载程序
   > - 引导加载程序将`xv6`内核加载到内核上
   >
   > **进入内核入口 → entry.S**
   >
   > - `CPU`从 `kernel/entry.S`开始运行`xv6`，为 xv6 设置好初始执行环境。
   > - `xv6`启动时，页式硬件处于禁用模式，虚拟地址直接映射到物理内存
   > - 设置内核栈指针，这样才能运行`C`代码。
   > - 跳转到 `start.c` ，先执行一些仅在机器模式下允许的配置，然后切换到管理模式，将 `main()`的地址写入寄存器`empc`将返回地址设为`main`，通过向页表寄存器`satp`中写`0`来禁止管理模式下的虚拟地址转换，将中断和异常委托给管理模式。
   > - 然后对时钟芯片编程产生定时器中断，调用`mret`返回到管理模式，由于之前将返回值设置为`main`，因此`mret`后面会返回到`main`函数，并以管理模式运行
   >
   > **内核初始化 (main.c)**
   >
   > - `main()` 调用一系列子系统初始化：
   >   - `consoleinit()`：初始化控制台。
   >   - `printfinit()`：调试打印。
   >   - `kinit()`：物理内存分配器。
   >   - `kvminit()`：内核页表。
   >   - `trapinithart()`：设置中断向量表。
   >   - `plicinit()`：中断控制器初始化。
   >   - `binit()`, `fileinit()`, `iinit()`, `virtio_disk_init()`：文件系统 & 块设备。
   >   - `procinit()`：进程表初始化。
   >
   > **创建第一个进程 (userinit)**
   >
   > - `userinit()` 创建 **第一个用户进程 `init`**。
   > - 给它分配一个进程控制块（PCB）、用户页表。
   > - 加载 `initcode.S`（用户空间的第一段小程序）。
   > - 把进程状态设为 RUNNABLE。
   >
   > **调度器 (scheduler)**
   >
   > - `main()` 最后调用 `scheduler()`，开始调度循环。
   > - `scheduler()` 找到第一个可运行进程（就是 `init`），进行上下文切换。
   > - CPU 切换到 U 模式，运行 `initcode.S`。
   >
   > **进入用户态 → initcode.S**
   >
   > - `initcode.S` 是一个很小的用户程序，主要任务是调用 `exec("/init")`。
   > - 这样就把真正的用户程序 `/init` 从文件系统加载到内存。
   >
   > **运行 `/init` 用户程序**
   >
   > - `/init` 是一个用户空间 C 程序，它会执行：
   >   - 打开控制台。
   >   - 创建第一个 shell (`sh`)。
   > - 至此，系统完全启动，用户可以在 shell 里运行命令。

4. 物理地址和虚拟地址

   > - `CPU`访问的真实硬件内存地址，没有`MMU`的系统中，程序访问的就是物理地址
   > - `CPU`指令中使用的地址，不直接访问内存，通过`MMU`转换成物理地址，每个进程看到的是独立的虚拟地址空间，由**页表**定义虚拟地址到物理地址的映射
   >   - `RISC-V`使用`Sv39`分页机制，对`64`位宽的地址只使用低`39`位，为每个进程维护一个独立的页表，并且所有进程共享同一个内核页表
   >   - `xv6`进程的地址空间分布：指令、全局变量、栈、堆、**`trapframe`**、**`trampoline`**
   >   - ![image-20250818172202649](C:\Users\19855\AppData\Roaming\Typora\typora-user-images\image-20250818172202649.png)
   >   - 进程状态：未使用、就绪、运行、阻塞、退出

5. `xv6`的进程

   > - `xv6`使用页表为每个进程提供自己的地址空间，`RISC-V`页表将虚拟地址转换成物理地址
   > - 每个进程都有一个**执行线程**来执行进程的指令，内核通过不断挂起当前运行的线程，恢复另一个进程的线程来实现调度
   > - 线程的大部分状态（本地变量、函数调用返回地址）存储在线程的栈上
   > - 每个进程有两个栈区：**用户栈、内核栈**；当执行用户指令的时候，内核栈为空；进程陷入内核时，内核代码在进程的内核栈上执行，此时其用户栈中仍然保存有数据，只是不活跃
   > - 进程通过执行`RISC-V`的**`ecall`**指令进行系统调用，该指令能够提升硬件特权级别，将程序计数器更改为内核定义的入口点，入口点的代码切换到内核栈，执行实现系统调用的内核指令；
   > - 系统调用完成，内核切换回用户栈，通过**`sret`**指令返回用户空间，降低硬件特权级别，在指令结束时恢复执行用户指令

6. ==**`理解xv6系统调用流程`**==

   > - 用户态调用封装的函数
   >
   >   > 调用的是库函数，被关联在`user/usys.S`中，对应一个系统调用号，并执行一个`ecall`指令
   >
   > - 执行`ecall`，`trap`陷入到内核
   >
   >   > `ecall`指令触发陷入`trap`， `CPU`从用户模式切换到管理模式，硬件会保存当前用户态的`pc`，跳转到`trap`向量`kernelvec.S`，保存寄存器到`trapframe`，跳转到`kernel/trap.c/usertrap()`
   >
   > - 内核处理系统调用
   >
   >   > `usertrap`检查`trap`原因，如果是系统调用，调用`syscall()`，会从`a7`寄存器中取出系统调用号，根据系统调用号，在`syscalls[]`这个注册表中找到对应的内核函数
   >
   > - 执行系统调用的具体实现
   >
   >   > 利用一些辅助函数，可以从`trapframe`中取出参数，`argint()、argaddr()`
   >
   > - 返回用户态
   >
   >   > 将系统调用函数返回值写入`a0`寄存器，回到`syscall()`、`usertrap()`、`usertrapret()`，切换到用户页表，将`CPU`状态恢复成用户态，执行`sret`指令，回到用户程序
   >
   > - ```markdown
   >   用户程序: write(fd, "hello", 5)
   >      ↓
   >   usys.S: a7=SYS_write; ecall
   >      ↓
   >   硬件: U-mode → S-mode
   >      ↓
   >   kernelvec.S → usertrap()
   >      ↓
   >   syscall()
   >      ↓
   >   sys_write() in sysfile.c
   >      ↓
   >   内核 write() → 文件系统/驱动
   >      ↓
   >   返回值放在 a0
   >      ↓
   >   usertrapret() → sret
   >      ↓
   >   回到用户态，write() 返回
   >   ```

7. ==**`基于用户态和内核态的数据传递和访问机制`**==

   > - 用户态传递参数给内核（系统调用号、系统调用参数）
   >   - `RISC-V`规定，系统调用参数放在`a0-a5`寄存器中，系统调用号在`a7`
   >   - 在`xv6`内核中，`syscall()`会从`trapframe`中取出这些寄存器，调用`argint()`、`argaddr()`得到参数：`argint(0, &fd); argaddr(1, &p);`
   > - 内核访问、修改用户态数据（用户态数据在虚拟地址空间中，而内核空间页表不能直接访问）
   >   - 用户传递的指针，是用户虚拟地址地址，内核不能直接当做内核地址用，因为用户空间和内核空间的页表不一致，`xv6`使用`copyin`、`copyout`完成数据搬运：`copyin(pagetable, dst, srcva, len);//从用户虚拟地址拷贝到内核缓冲区`，`copyout(pagetable, dstva, src, len);//将数据写回用户虚拟地址`
   > - 在系统调用执行结束，把返回值写回`a0`寄存器，用户态函数就能拿到结果

8. ==**`拓展实现trace、sysinfo等系统调用`**==

   > - 系统调用：操作系统通过`CPU`的特权模式将用户态和内核态隔离，保证了用户程序无法直接访问内核资源，规避了误操作和恶意行为，系统调用作为用户程序和内核交互的桥梁，运行用户程序通过受控的接口向内核请求服务，保证系统的安全性和稳定性
   >
   > - 系统调用机制：通过库函数间接发起系统调用，会触发软件中断或陷阱，引发`CPU`起换到内核态，内核根据系统调用号来确定要执行的服务，完成服务后，将结果或错误码写入用户程序的寄存器中，然后返回到用户态继续执行程序
   >
   > - 由于内核和用户进程的页表不同，寄存器也不互通，参数无法直接通过c语言参数的形式传递，因此使用`argint()`等系列函数，从进程的`trapframe`中读取用户进程寄存器中的参数
   >
   > - `trace 系统调用：需要记录系统调用号、参数 → 内核打印 → 返回给用户。`
   >
   >   - 对`trace 32 grep hello README`指令，利用`32`设置按位计算的掩码，在执行`grep hello README`时，将掩码对应跟踪的系统调用过程进行输出
   >
   >   - ```c
   >     // trace 系统调用流程
   >     trace.c				// trace(atoi(argv[1])执行系统调用
   >     user/user.h			// 用户态程序函数trace(int mask)声明
   >     user/usys.S			// usys.pl:entry("trace");会生成usys.S，提供trace系统调用的接口，填入a7寄存器一个系统调用号，然后执行ecall陷入内核
   >     kernel/trampoline.S/uservec		// trap向量入口，保存用户上下文，切换内核栈
   >     kernel/trap.c/usertrap()		// 判断trap类型（syscall、外部中断、异常），如果是系统调用，需要调用syscall
   >     kernel/syscall.c	// 到达内核统一syscall()，所有系统调用都会在此处理，进行分发
   >     kernel/syscall.c	// 根据跳板传进来的a7系统调用号，查询syscall.h和syscall[]注册表中对应的内核函数映射关系，调用具体内核函数实现
   >     kernel/sysproc.c	// 处理具体的sys_trace()函数逻辑，使用argint、argaddr获取参数
   >     kernel/syscall.c	// 在a0写入系统调用函数返回值
   >     kernel/trap.c/usertrapret()	// 准备返回用户态，恢复用户态上下文，切换用户页表
   >     kernel/trampoline.S/userret	// 执行sret指令，真正切换到用户态，继续执行用户程序
   >     ```
   >
   > - `sysinfo 系统调用：需要把内核里的内存使用信息、进程数拷贝到用户态的结构体里。`
   >
   >   - `sinfo(&info);`在用户态调用
   >
   >   - ```c
   >       uint64 dstaddr;		//  获取用户虚拟地址，第一个实参info，然后在函数内形参进行填充
   >       argaddr(0, &dstaddr); 
   >       // 从内核空间拷贝数据到用户空间
   >       if(copyout(myproc()->pagetable, dstaddr, (char*)&info, sizeof info) < 0) return -1;
   >     ```

9. ==`基于共享页表机制改写 copyin / copyinstr，简化系统调用数据传输流程`==

   > 

10. ==`分析中断处理流程`==

    > 

11. ==`基于时钟中断实现alarm系统调用`==

    > 

12. ==`支持用户态触发定时任务`==

    > 

13. 