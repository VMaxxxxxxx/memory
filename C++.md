1. `NULL`和`nullptr`的区别

2. `sizeof`获取变量或类型的大小

3. 常量指针、指针常量、常量指针常量的区别

4. `static`在不同场景下的作用（局部变量、全局变量、全局函数、类静态成员、类静态函数、类静态成员初始化）

   > 在不同位置的核心作用，是为了延长生命周期、限制作用域、限制链接性，在类中，强调归属于类而非对象

5. `extern`的作用

6. `const`的作用

7. 强制类型转换（`static_cast`、`dynamic_cast`、`reinterpret_cast`、`const_cast`）

8. `struct`和`class`的区别

9. 函数指针和指针函数的区别

10. 函数指针的概念及使用场景

11. 关键字（`const`、`static`、`define`、`typedef`、`inline`、`new`、`malloc`、`constexpr`、`volatile`、`extern`、`++`、`explicit`）

12. 数据类型（基本数据类型（字符型、整形、浮点型、布尔型、修饰符、空类型）、派生数据类型（指针、引用、数组、）、用户自定义数据类型（结构体、类、枚举、联合体、类型别名））

13. 指针和引用的区别

14. 静态局部变量、全局变量、局部变量的特点，使用场景

15. `STL`容器有哪些（序列式容器[`vector`、`list`、`deque`、`forward_list`、`array`]、关联式容器[`set`、`map`、`multiset`、`multimap`]、无序关联式容器[`unordered_set`、`unordered_multiset`、`unordered_map`、`unordered_multimap`]）

16. `STL`容器各自的特点、使用场景

17. 其他常用结构（容器适配器[`stack`、`queue`、`priority_queue`]、标准库的通用数据打包类型[`pair`、`tuple`]）

18. `STL`包含哪些内容（容器、迭代器、算法、仿函数、适配器（容器、函数）、分配器）

19. `vector`是如何保证元素连续存储的，如何实现扩容的

20. `vector`的`push_back`和`emplace_back`有什么区别

21. `list`和`vector`的区别

22. `list`实现元素插入和删除的原理

23. `set`和`map`的底层实现有什么区别

24. `map`、`deque`、`list`的实现原理

25. 关联式容器`map`、`multimap`、`set`、`multiset`之间有什么区别

26. 在`map`和`set`中查找元素有哪些方法

27. `map`和`unordered_map`的区别

28. 迭代器的作用

29. 迭代器失效的概念、原因、避免措施

30. `vector`的实现原理

31. `list`的实现原理

32. 介绍智能指针（`shared_ptr`、`unique_ptr`、`weak_ptr`、`auto_ptr`（被移除））

33. 堆和栈的区别

34. 进程地址空间（内存分区）（内核空间、环境变量、命令行参数、栈、共享区（内存映射区）、堆、BSS未初始化全局/静态变量、Data初始化全局/静态变量、常量区（只读数据段）、代码段）

35. 内存泄露的概念，产生原因，分类、避免措施

36. `new`和`malloc`的区别，`delete`和`free`的区别

37. 悬空指针的概念，产生原因，避免措施

38. 野指针和悬浮指针的区别

39. 内存对齐的概念、为什么要考虑内存对齐

40. 实现内存拷贝函数`char* strcpy(char* strDest, char* strSrc)`

41. 为什么返回的是`strDest`的原始值，而不是`strSrc`

42. 如何实现自重叠（`src <= dst <= src + strlen(src`）的拷贝

43. 实现`String`的构造函数（`char *`）、拷贝构造函数（深拷贝）、赋值构造函数（赋值运算符重载）、析构函数

44. 说一说`this`指针

45. 介绍`C`和`C++`的内存分配方式

46. 计算机中的乱序执行

47. 实现字符串操作函数（`strcpy`、`strlen`、`strcat`、`strcmp`）

48. `C++`面向对象特性（封装、继承、多态）

49. 编译时多态（静态多态：运算符重载、函数重载）和运行时多态（动态多态：虚函数、继承），前者是否能替代后者

50. 如何实现多态（虚函数、虚函数表、重写基类方法、基类类型指向派生类对象、调用虚函数）

51. 虚函数调用的底层机制，虚函数表`vtable`和虚指针`vptr`的概念，动态绑定过程（静态绑定）

52. 如何不使用虚函数实现运行时多态

53. 重载与重写区别以及实现方式，重载能否靠返回值来区分，`override`的作用，不加`virtual`有什么问题

54. 介绍访问修饰符（`public`、`private`、`protected`）的区别

55. 多重继承的概念，存在的问题（菱形继承）

56. 构造函数（默认构造函数、含参构造函数、拷贝构造函数、移动构造函数、委托构造函数、转换构造函数、初始化列表构造函数）

57. 虚函数与纯虚函数的区别

58. 抽象类和纯虚函数的关系

59. 虚析构函数的作用

60. 为什么有虚析构函数，而构造函数不能设置`virtual`

61. 哪些函数不能声明为虚函数

62. 什么是友元函数

63. 什么是内联函数

64. 深拷贝和浅拷贝的区别

65. 什么是运算符重载

66. 左值引用和右值引用的概念、区别

67. `C++`中的`socket`套接字通信过程（服务器端（创建、绑定、监听、接受、收发、关闭）、客户端（创建、设置、连接、收发、关闭））

68. 什么是`socket`（操作系统提供的网络通信端点，一端关联应用程序，一端关联`TCP/IP`协议栈）

69. `socket`相关函数（`socket()`、`bind()`、`listen()`、`accept()`、`connect()`、`send()`、`recv()`、`read()`、`write()`、`close()`）

70. `socket`相关结构体（`sockaddr`、`sockaddr_in`、`in_addr`、`sockaddr_in6`、`in6_addr`、`hostent`）

71. 字节序转换函数（`htons`、`htonl`、`ntohs`、`ntohl`），为什么要转换

72. 为什么服务器端需要两个`socket`

73. `TCP`连接关闭的`shutdown`和`close`有什么区别

74. 如何优化`socket`流程（设置非阻塞`I/O`、多线程处理、设置超时时间、地址复用）

75. `Windows`下使用的`socket`接口`API`是什么

76. `socket`编程模式（阻塞模式与非阻塞模式`IO`的区别），切换函数（`fcntl`、`ioctl`）

77. 如何实现在服务器端同时处理多个客户端的连接请求（多进程多线程模型，`IO`多路复用机制（`select`、`poll`、`epoll`）、异步`IO`模型）

78. `epoll`的触发模式（水平`LT`、边缘`ET`）有什么区别，边缘模式为什么要求非阻塞，`epoll`的底层机制是什么

79. 为什么`select`的`FD`有`1024`限制

80. 如何处理多线程服务器中的竞态条件

81. 网络编程中的粘包和拆包问题处理方案（定长数据、分割标识符、头部标识长度、自定义协议）

82. `std::thread`线程构造函数

83. `RAII`的概念（`resource acquisition is initialization`）

84. `lock_guard`的概念、作用、特点

85. `unique_lock`的概念、作用、特点，与`lock_guard`的区别

86. 如何创建和管理线程，`join`和`detach`有什么区别

87. `std::async`、`std::future`和`std::promise`的作用

88. `std::mutex`的用法

89. 介绍`std::atomic`

90. 介绍`C++`的多线程同步机制（互斥锁、条件变量、原子操作、信号量）

91. 死锁、读写锁、无锁编程的概念

92. 如何实现一个线程池（一个任务队列+一组工作线程+从任务队列取出任务的机制+同步机制）

93. `C++11`的新特性有哪些（语法的改进、标准库扩充）

94. 介绍智能指针（`shared_ptr`、`unique_ptr`、`weak_ptr`），以及构造智能指针的方法

95. 什么是循环引用

96. 共享指针的实现机制（引用参数、重载机制），线程安全性

97. 自动类型推导`auto`和`decltype`的用法

98. 解释概念：左值、右值、左值引用、右值引用（将亡值、纯右值）、移动语义（`std::move`）、完美转发（`std::forward`）

99. 基于范围的`for`循环的用法（遍历）

100. 列表初始化(赋值、花括号赋值、花括号、圆括号)

101. `lambda`表达式的概念、语法、特点、用途（`STL`算法库）

102. 介绍`lambda`的捕获列表有哪些捕获类型

103. 介绍`C++`中的异常处理机制（`assert`、状态码、`return`、抛出异常（`try`、`catch`、`throw`））

104. 介绍`C++`中抛出异常和匹配异常的原则

105. 构造函数和析构函数中的异常问题

106. 列出常见的异常类型（标准库）

107. 什么是异常安全的代码，如何编写异常安全的代码

108. 命名空间的作用

109. 内联函数的工作原理，与`lambda`表达式的区别

110. 如何在`C++`中实现一个不可变的字符串类