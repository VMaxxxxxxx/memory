1. 从前种种譬如昨日死，从后种种譬如今日生

2. 排序算法

   > ![img](https://cdn.xiaolincoding.com//picgo/image-20240725233717608.png)
   >
   > 1. 插入排序类
   >
   >    1. 直接插入排序
   >
   >       > - **原理**：将待排序元素逐个插入到已排序序列的合适位置，形成有序序列
   >       > - **时间复杂度**：O(n²)，最优 O(n)，最差O(N^2)
   >       > - **空间复杂度**：O(1)
   >       > - **是否稳定**：✅ 是
   >       > - **适用场景**：**数据基本有序、小规模数据**
   >       > - **优点**：简单，已排序数据性能好
   >       > - **缺点**：大量元素移动
   >       >
   >       > ```cpp
   >       > void insertionSort(vector<int>& arr) {
   >       >     for (int i = 1; i < arr.size(); ++i) {
   >       >         int key = arr[i], j = i - 1;
   >       >         while (j >= 0 && arr[j] > key) {
   >       >             arr[j + 1] = arr[j];  // 向后移动元素
   >       >             j--;
   >       >         }
   >       >         arr[j + 1] = key;  // 插入 key
   >       >     }
   >       > }
   >       > ```
   >
   >    2. 希尔排序
   >
   >       > - **原理**：将数组按照一定的“间隔”分组做插入排序，逐渐缩小间隔直至1
   >       > - **时间复杂度**：平均 O(n^1.3)，最坏 O(n²)
   >       > - **空间复杂度**：O(1)
   >       > - **是否稳定**：❌ 否
   >       > - **适用场景**：中等数据量，不要求稳定
   >       > - **优点**：效率高于插入排序
   >       > - **缺点**：稳定性差
   >       >
   >       > ```cpp
   >       > void shellSort(vector<int>& arr) {
   >       >     int n = arr.size();
   >       >     for (int gap = n / 2; gap > 0; gap /= 2)       // 1. 初始化间隔并逐步缩小
   >       >         for (int i = gap; i < n; ++i) {             // 2. 对每个子序列进行插入排序
   >       >             int temp = arr[i], j = i;
   >       >             while (j >= gap && arr[j - gap] > temp) // 3. 插入排序逻辑
   >       >                 arr[j] = arr[j - gap], j -= gap;
   >       >             arr[j] = temp;
   >       >         }
   >       > }
   >       > ```
   >
   > 2. 选择排序类
   >
   >    1. 直接选择排序
   >
   >       > - **原理**：通过不断选择未排序部分的最小或最大元素，并将其放置在已排序部分的末尾或开头。
   >       > - **时间复杂度**：O(n²)，最好O(N^2)，最差O(N^2)
   >       > - **空间复杂度**：O(1)
   >       > - **是否稳定**：❌ 否
   >       > - **适用场景**：内存写入次数少的场景
   >       > - **优点**：交换次数最少
   >       > - **缺点**：比较次数多
   >       >
   >       > ```cpp
   >       > void selectionSort(vector<int>& arr) {
   >       >     int n = arr.size();
   >       >     for (int i = 0; i < n - 1; ++i) {
   >       >         int min_idx = i;
   >       >         for (int j = i + 1; j < n; ++j) {
   >       >             if (arr[j] < arr[min_idx]) {
   >       >                 min_idx = j;
   >       >             }
   >       >         }
   >       >         if (min_idx != i) {  // 避免不必要的交换
   >       >             swap(arr[i], arr[min_idx]);
   >       >         }
   >       >     }
   >       > }
   >       > ```
   >
   >    2. 堆排序
   >
   >       > - **原理**：通过将待排序元素构建成一个最大堆或最小堆，然后将堆顶元素与末尾元素交换，再重新调整堆，重复该过程直到排序完成。
   >       > - **时间复杂度**：O(n log n)，无论最好最坏
   >       > - **空间复杂度**：O(1)
   >       > - **是否稳定**：❌ 否
   >       > - **适用场景**：内存受限、不要求稳定
   >       > - **优点**：空间小，不易被卡
   >       > - **缺点**：不稳定
   >       > - 说明1：
   >       >   - 大顶堆：每个节点 ≥ 子树中的每个节点
   >       >   - 小顶堆：每个节点 ≤ 子树中的每个节点
   >       > - 说明2：
   >       >   - 堆的要求：
   >       >     - 必须是完全二叉树
   >       >     - 符合大顶堆或小顶堆的定义
   >       >   - 数据结构：用一维数组保存，不保存左右节点的指针，用下标索引左右节点和父节点
   >       >     - 父节点 i 的左节点：2 i  + 1
   >       >     - 父节点 i 的右节点：2 i + 2
   >       >     - 子节点 j 的父节点：向下取整[(j - 1) / 2]
   >       >   - 堆排序的两步走：
   >       >     - 建堆（将一个无需的数组转化为最大堆）：直接在原数组上建堆
   >       >     - 排序（调整）：数组的第一个元素是堆顶，将其与最后一个元素交换，放到了下标n的位置，末尾元素变成了最大值，将剩余元素重新**堆化**成一个大顶堆
   >       > - 说明3：
   >       >   - 整个堆排序过程，只需要个别的临时空间，是**原地**排序算法
   >       >   - 建堆的时间复杂度O(N)，排序过程O(N logN)，整体O(N logN)
   >       >   - 在排序的过程中，需要将堆顶和最后一个节点进行互换，有可能会改变值相同数据的原始相对顺序，因此**不稳定**
   >       >
   >       > ```cpp
   >       > void heapify(vector<int>& arr, int n, int i) {
   >       >     int largest = i;          // 当前节点
   >       >     int left = 2 * i + 1;     // 左子节点
   >       >     int right = 2 * i + 2;    // 右子节点
   >       >     // 找到当前节点、左子节点、右子节点中的最大值
   >       >     if (left < n && arr[left] > arr[largest])
   >       >         largest = left;
   >       >     if (right < n && arr[right] > arr[largest])
   >       >         largest = right;
   >       >     // 如果最大值不是当前节点，交换并递归调整
   >       >     if (largest != i) {
   >       >         swap(arr[i], arr[largest]);
   >       >         heapify(arr, n, largest);
   >       >     }
   >       > }
   >       > 
   >       > void heapSort(vector<int>& arr) {
   >       >     int n = arr.size();
   >       >     // 1. 构建最大堆（从最后一个非叶子节点开始）
   >       >     for (int i = n / 2 - 1; i >= 0; i--)
   >       >         heapify(arr, n, i);
   >       >     // 2. 逐个提取堆顶元素（最大值）并调整堆
   >       >     for (int i = n - 1; i > 0; i--) {
   >       >         swap(arr[0], arr[i]);  // 将最大值移到数组末尾
   >       >         heapify(arr, i, 0);     // 调整剩余堆
   >       >     }
   >       > }
   >       > ```
   >
   > 3. 交换排序类
   >
   >    1. 冒泡排序
   >
   >       > - **原理**：通过相邻元素的比较和交换，每次将最大或最小的元素逐步冒泡到最后或最前。
   >       > - **时间复杂度**：O(n²)，最好O(N)，最坏O(N^2)
   >       > - **空间复杂度**：O(1)
   >       > - **是否稳定**：✅ 是
   >       > - **适用场景**：小规模数据、教学
   >       > - **优点**：简单好理解
   >       > - **缺点**：效率低
   >       > - 说明：最好时间复杂度出现在：当待排序数组已经有序时，一次遍历就可以确定排序完成，此时O(N)；平均时间复杂度O(N^2)，因为在排序过程中，需要进行多次遍历和元素交换，每次遍历都需要比价相邻元素并决定是否交换。
   >       >
   >       > ```cpp
   >       > void bubbleSort(vector<int>& arr) {
   >       >     int n = arr.size();
   >       >     bool swapped;
   >       >     for (int i = 0; i < n - 1; ++i) {
   >       >         swapped = false;
   >       >         for (int j = 0; j < n - 1 - i; ++j) {
   >       >             if (arr[j] > arr[j + 1]) {
   >       >                 swap(arr[j], arr[j + 1]);
   >       >                 swapped = true;
   >       >             }
   >       >         }
   >       >         // 如果内循环没有发生交换，说明数组已经有序
   >       >         if (!swapped) break;
   >       >     }
   >       > }
   >       > ```
   >
   >    2. 快速排序
   >
   >       > - **原理**：通过选择一个基准元素 pivot，将数组划分为左右区间的子数组，使得左子数组的元素都小于或等于 pivot，右子数组的元素都大于或等于基准元素，然后对子数组进行递归排序。
   >       > - **时间复杂度**：平均 O(n log n)，最坏 O(n²)，最好O(N logN)
   >       > - **空间复杂度**：O(log n)，最好O(lonN)，最差O(N^2)，每次选择的基准元素都是最大最小值时
   >       > - **是否稳定**：❌ 否
   >       > - **适用场景**：通用排序，最常用
   >       > - **优点**：快，常为面试首选
   >       > - **缺点**：不稳定，极端情况慢
   >       > - 说明1：快排使用了分治策略（分而治之，将复杂问题划分成一个多个相似子问题，再把子问题进行划分，直到更小的问题可以简单求解，原问题的解=子问题解的合并）
   >       > - 说明2：快速排序的三步走：
   >       >   - 取出当前序列的一个数作为基准数
   >       >   - 执行一次快速partition：将比这个数大的数全部放到其右边，把小于等于其的数全部放到左边
   >       >   - 分别对基准的左右两边重复上述操作，直到数组完全排序
   >       > - 说明3：基准元素的选择对快速排序的性能和效率有直接影响，固定位置选择在数组有序或逆序的情况下会导致分区极不平衡，每次划分只能减少一个元素，随机选择可以在概率上极大降低连续选择到最值的可能性，三数取中法（l, m, r位置的元素取中位数）
   >       > - 说明4：被认为是基于比较的内部排序中最好的方法，当待排序的关键字是**随机分布**时，平均时间最短
   >       >
   >       > ```cpp
   >       > // Lomuto分区：单指针，逐步将<=基准的元素移到左侧
   >       > int partition(vector<int>& arr, int left, int right) {
   >       >     // 随机选择 pivot 并交换到最右侧
   >       >     int pivot_idx = left + rand() % (right - left + 1);
   >       >     swap(arr[pivot_idx], arr[right]);
   >       >     // 选择最右侧元素 arr[right] 作为 pivot（基准）。
   >       >     // 使用指针 i 维护“小于等于 pivot”的区域的边界。
   >       >     // 遍历 left 到 right-1，将 ≤ pivot 的元素交换到左侧（i 的位置）。
   >       >     // 最后将 pivot 放到正确位置（i+1），并返回该位置。
   >       >     int pivot = arr[right], i = left - 1;
   >       >     for (int j = left; j < right; ++j)
   >       >         if (arr[j] <= pivot)
   >       >             swap(arr[++i], arr[j]);
   >       >     swap(arr[i + 1], arr[right]);
   >       >     return i + 1;
   >       > }
   >       > 
   >       > void quickSort(vector<int>& arr, int left, int right) {
   >       >     if (right - left + 1 <= 16) {  // 阈值可调整
   >       >         insertionSort(arr, left, right);  // 小区间使用插入排序
   >       >         return;
   >       >     }
   >       >     // if(left >= right) return;
   >       >     int p = partition(arr, left, right);
   >       >     quickSort(arr, left, p - 1);
   >       >     quickSort(arr, p + 1, right);
   >       > }
   >       > ```
   >       >
   >       > ```cpp
   >       > // Hoare分区：双指针，左右指针找到逆序对后直接交换
   >       > int partition(vector<int>& arr, int left, int right) {
   >       >     int pivot = arr[left + (right - left) / 2];  // 选中间元素为基准（可改为随机）
   >       >     int i = left - 1, j = right + 1;            // 初始化指针
   >       >     while (true) {
   >       >         do { i++; } while (arr[i] < pivot);      // 左指针向右找 ≥ 基准的元素
   >       >         do { j--; } while (arr[j] > pivot);      // 右指针向左找 ≤ 基准的元素
   >       >         if (i >= j) return j;                    // 重叠时终止
   >       >         swap(arr[i], arr[j]);                    // 交换逆序对
   >       >     }
   >       > }
   >       > 
   >       > void quickSort(vector<int>& arr, int left, int right) {
   >       >     if (left >= right) return;
   >       >     int p = partition(arr, left, right);        // 获取分区点
   >       >     quickSort(arr, left, p);                    // 递归排序左半部分（注意包含p）
   >       >     quickSort(arr, p + 1, right);               // 递归排序右半部分
   >       > }
   >       > ```
   >       >
   >       > 
   >
   > 4. 归并排序
   >
   >    > - **原理**：分治法，将数组不断分割成更小的子数组，将子数组进行合并，合并过程中进行排序。
   >    > - **时间复杂度**：O(n log n)，无论最好最坏
   >    > - **空间复杂度**：O(n)
   >    > - **是否稳定**：✅ 是
   >    > - **适用场景**：要求稳定性的大数据排序（如外部排序）
   >    > - **优点**：稳定，性能稳定
   >    > - **缺点**：需要额外空间
   >    >
   >    > ```cpp
   >    > void merge(vector<int>& arr, int l, int m, int r) {
   >    >     // 创建临时数组 left 和 right 存储左右两半的数据。
   >    > 	// 使用双指针（i 和 j）合并两个有序数组，按升序写回原数组 arr。
   >    > 	// 处理剩余元素（如果 left 或 right 还有未合并的元素）。
   >    >     vector<int> left(arr.begin() + l, arr.begin() + m + 1);
   >    >     vector<int> right(arr.begin() + m + 1, arr.begin() + r + 1);
   >    >     int i = 0, j = 0, k = l;
   >    >     while (i < left.size() && j < right.size())
   >    >         arr[k++] = (left[i] <= right[j]) ? left[i++] : right[j++];
   >    >     while (i < left.size()) arr[k++] = left[i++];
   >    >     while (j < right.size()) arr[k++] = right[j++];
   >    > }
   >    > void mergeSort(vector<int>& arr, int l, int r) {
   >    >     // 递归地将数组分成两半[l, m] 和 [m+1, r]，直到子数组长度为 1（l >= r）
   >    > 	// 然后调用 merge 合并两个有序子数组。
   >    >     if (l >= r) return;
   >    >     int m = (l + r) / 2;
   >    >     mergeSort(arr, l, m);
   >    >     mergeSort(arr, m + 1, r);
   >    >     merge(arr, l, m, r);
   >    > }
   >    > ```
   >
   > 5. 基数排序
   >
   >    > **原理**：按位排序，通常从最低位到最高位。
   >    >
   >    > **时间复杂度**：O(n × d)
   >    >
   >    > **是否稳定**：✅ 是
   >    >
   >    > **适用场景**：定长整数/字符串排序（如手机号、身份证号）
   >
   > - 测试输入输出
   >
   >   > ```c++
   >   > #include <iostream>
   >   > #include <vector>
   >   > #include <sstream>
   >   > using namespace std;
   >   > 
   >   > // 声明各排序算法
   >   > void bubbleSort(vector<int>& arr);
   >   > void insertionSort(vector<int>& arr);
   >   > void selectionSort(vector<int>& arr);
   >   > void mergeSort(vector<int>& arr, int l, int r);
   >   > void quickSort(vector<int>& arr, int l, int r);
   >   > void heapSort(vector<int>& arr);
   >   > void shellSort(vector<int>& arr);
   >   > 
   >   > // 打印数组函数
   >   > void printArray(const vector<int>& arr, const string& sortName) {
   >   >     cout << sortName << ": ";
   >   >     for (int num : arr) cout << num << " ";
   >   >     cout << endl;
   >   > }
   >   > 
   >   > // 输入处理函数
   >   > vector<int> getInputArray() {
   >   >     cout << "请输入要排序的数字（用空格分隔，回车结束）: ";
   >   >     string line;
   >   >     getline(cin, line);
   >   >     
   >   >     vector<int> arr;
   >   >     istringstream iss(line);
   >   >     int num;
   >   >     while (iss >> num) {
   >   >         arr.push_back(num);
   >   >     }
   >   >     return arr;
   >   > }
   >   > 
   >   > int main() {
   >   >     // 获取用户输入
   >   >     vector<int> arr = getInputArray();
   >   >     if (arr.empty()) {
   >   >         cout << "输入为空，请重新运行程序！" << endl;
   >   >         return 0;
   >   >     }
   >   > 
   >   >     // 各排序算法测试
   >   >     vector<int> arr_copy;
   >   >     
   >   >     // 1. 冒泡排序
   >   >     arr_copy = arr;
   >   >     bubbleSort(arr_copy);
   >   >     printArray(arr_copy, "Bubble Sort");
   >   >     
   >   >     // 2. 插入排序
   >   >     arr_copy = arr;
   >   >     insertionSort(arr_copy);
   >   >     printArray(arr_copy, "Insertion Sort");
   >   >     
   >   >     // 3. 选择排序
   >   >     arr_copy = arr;
   >   >     selectionSort(arr_copy);
   >   >     printArray(arr_copy, "Selection Sort");
   >   >     
   >   >     // 4. 归并排序
   >   >     arr_copy = arr;
   >   >     mergeSort(arr_copy, 0, arr_copy.size() - 1);
   >   >     printArray(arr_copy, "Merge Sort");
   >   >     
   >   >     // 5. 快速排序
   >   >     arr_copy = arr;
   >   >     quickSort(arr_copy, 0, arr_copy.size() - 1);
   >   >     printArray(arr_copy, "Quick Sort");
   >   >     
   >   >     // 6. 堆排序
   >   >     arr_copy = arr;
   >   >     heapSort(arr_copy);
   >   >     printArray(arr_copy, "Heap Sort");
   >   >     
   >   >     // 7. 希尔排序
   >   >     arr_copy = arr;
   >   >     shellSort(arr_copy);
   >   >     printArray(arr_copy, "Shell Sort");
   >   > 
   >   >     return 0;
   >   > }
   >   > ```

3. 什么是排序稳定性，稳定和不稳定排序算法各有什么特点

   > 指：多个具有相同关键字的元素，在排序前后的序列中保持相同的相对顺序
   >
   > 两个元素有相同的key，在排序前，第一个元素在第二个之前，排序后第一个元素也应该在第二个元素前
   >
   > ```cpp
   > [("alice", 25), ("bob", 25), ("charlie", 20)]
   > // 按照年龄排序
   > [("charlie", 20), ("alice", 25), ("bob", 25)]	// 稳定
   > [("charlie", 20), ("bob", 25), ("alice", 25)]	// 不稳定
   > ```
   >
   > 特点：
   >
   > - 稳定排序适用于需要保持相对顺序关系的场景
   > - 不稳定排序可能会更快

4. 快速排序性能这么好，冒泡排序还有必要吗

   > 快速排序在基准元素选择不合适的时候，会导致极端的划分不平衡，算法性能和效率较差
   >
   > 冒泡排序在**小规模**或**基本有序**的数据场景下，更简单，更直接
   >
   > 冒泡排序是稳定的，原地的算法，适合于要求稳定性和空间复杂度的场景

5. 如果对一个很大的、没办法一次性在内存中排序的数据集，进行排序

   > 外部排序
   >
   > 1. 部分排序阶段
   >
   >    > 将待排序的文件拆分成多个部分，使得每个部分都能写入内存，选择合适的内部排序算法（快速排序），堆多个文件进行部分排序，输出到容量更大的外存临时文件中，每个临时文件都是有序的，称为顺短
   >
   > 2. 归并阶段
   >
   >    > 对多个顺段进行合并，思想类型归并排序，二路归并，每次都将两个连续的顺段合并成一个更大的顺段。在归并过程中同样由于内存限制，分段进行读取，在内存中以确定顺序进行部分排序，并输出到外存文件，不断重复，直到两个顺段被完整遍历，经过多层归并，得到完整的顺序文件。
   >
   > <img src="https://cdn.xiaolincoding.com//picgo/image-20240725233745307.png" alt="img" style="zoom:33%;" />
   >
   > 其中的时间开销取决于IO，归并的层数越低越快，降低归并层数，使用**败者树**：
   >
   > > <img src="https://cdn.xiaolincoding.com//picgo/image-20240725233754449.png" alt="img" style="zoom:33%;" />
   > >
   > > - 败者树中的非叶子节点中存储的是胜利者，叶子节点存储的是失败者，每次比较都由胜利者参与
   > > - 外部排序思路：先使用内部排序生成n各有序顺段，然后以k个文件为一组，每次流式从各个文件读一个，借助败者树选出最小的一个进行输出，可以做到将k各顺段合并成一个顺段，反复至所有顺段归并成一个顺段

6. 如何在长度为N的数组中，找出最大的前K个值

   > 1. 排序法
   >
   >    > 场景：对实现复杂度低、K接近N，时间复杂度O(N log N)
   >    >
   >    > 原理：对整个数组排序（快速排序），取前K各元素
   >    >
   >    > 缺点：K 远小于 N的事实，对整个数组排序是低效的
   >    >
   >    > ```c++
   >    > vector<int> topK_sort(vector<int>& nums, int k) {
   >    >     sort(nums.begin(), nums.end()); // 默认升序
   >    >     return vector<int>(nums.end() - k, nums.end());
   >    > }
   >    > ```
   >
   > 2. 堆（优先队列）
   >
   >    > 场景：N较大的大数据流，K很小，时间复杂度O(N log K)，内存受限（只取前K个，不要求完整排序）
   >    >
   >    > 原理：使用一个**最小堆**，维护K个最大的元素（遍历数组，堆的大小小于K时构建堆），后续元素则首先与堆顶比较，只有比堆顶元素大的，再去替换堆顶，向下调整，维护这个最小堆。
   >    >
   >    > ```c++
   >    > vector<int> topK_heap(vector<int>& nums, int k) {
   >    >     priority_queue<int, vector<int>, greater<int>> minHeap;
   >    >     for (int num : nums) {
   >    >         if (minHeap.size() < k) minHeap.push(num);
   >    >         else if (num > minHeap.top()) {
   >    >             minHeap.pop();
   >    >             minHeap.push(num);
   >    >         }
   >    >     }
   >    >     vector<int> res;
   >    >     while (!minHeap.empty()) {
   >    >         res.push_back(minHeap.top());
   >    >         minHeap.pop();
   >    >     }
   >    >     return res;
   >    > }
   >    > ```
   >    >
   >    > **最小堆**：堆的大小为K，堆顶是这K个数据中最小的，后续元素是找每个元素比堆顶大的，最终生成一个包含了K个最大元素的最小堆
   >    > **最大堆**：所有数据建堆，堆顶是最大的，需要出堆K次才能找到第K大，空间复杂度高
   >
   > 3. 快速选择算法
   >
   >    > 场景：K较大或需要线性时间复杂度，平均时间复杂度O(N)，最坏O(n ^ 2)，结果无序
   >    >
   >    > 原理：基于快排partition，找到第K大的元素，取前K个
   >    >
   >    > 优点：在数据可以全部放入内存时，效率很高
   >    >
   >    > ```cpp
   >    > int partition(vector<int>& nums, int l, int r) {
   >    >     int pivot = nums[r], i = l;
   >    >     for (int j = l; j < r; ++j)
   >    >         if (nums[j] >= pivot)
   >    >             swap(nums[i++], nums[j]);
   >    >     swap(nums[i], nums[r]);
   >    >     return i;
   >    > }
   >    > 
   >    > void quickSelect(vector<int>& nums, int l, int r, int k) {
   >    >     if (l >= r) return;
   >    >     int p = partition(nums, l, r);
   >    >     if (p == k) return;
   >    >     else if (p < k) quickSelect(nums, p + 1, r, k);
   >    >     else quickSelect(nums, l, p - 1, k);
   >    > }
   >    > 
   >    > vector<int> topK_quickSelect(vector<int>& nums, int k) {
   >    >     quickSelect(nums, 0, nums.size() - 1, k - 1);
   >    >     return vector<int>(nums.begin(), nums.begin() + k);
   >    > }
   >    > ```
   >    >
   >    > 

7. 