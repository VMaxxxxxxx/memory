1. `Reactor`模式的核心思想

   > 本质是**`事件驱动、非阻塞IO`**，主线程只负责监听事件（如`socket`可读可写），一旦有事件发生就分发给对应的处理器（回调函数）处理；可以高效处理大量并发的连接，避免每个连接都使用一个线程或进程

2. 事件循环**`EventLoop`**

   > 作为`Reactor`的核心，在`while`中调用`epoll`、`select`、`poll`等系统调用，等待`IO`事件发生
   >
   > 当事件发生时，事件循环会分发事件给注册的回调处理函数

3. 事件分发器`Dispatcher`

   > 负责将事件（某`fd`可读可写）分发给对应的处理逻辑（读取请求等）

4. 线程池`ThreadPool`

   > 通过**预先创建**多个工作线程，避免频繁创建/销毁线程带来的开销，每个工作线程都运行自己的事件循环`EventLoop`，负责处理分配给他的连接上的事件

5. `one loop per thread`模型

   > 每个工作线程有独立的事件循环（**一个线程一个事件循环**），**主线程**只负责监听新连接，接收到新连接后将其分配给工作线程的事件循环，由该线程负责后续的`IO`和事件处理（读写、协议解析、响应），避免了多线程竞争同一个事件循环的锁，提高了多核利用率和并发处理能力

6. 如何区分线程类型

   > 线程池结构体里有主事件循环，能找到对应的线程`ID`，其他工作线程比较`pthread_self`进行判断
   >
   > 线程池管理所有的工作线程，主线程和工作线程的职责和入口函数不同

7. 并发性能

   > `QPS`每秒请求数、并发连接数、延迟，这个受硬件、操作系统、网络影响，单机环境下的`Reactor`线程池模型，可以支持成千上万的并发连接
   >
   > 经过`wrk`测试，启动`4`线程维护`100`个并发连接，当持续向目标服务器发送`HTTP`请求，然后收集响应事件、成功、失败等数据，统计出的`QPS`可达`1000+`，平均延迟`50ms`左右，已经远超设计初衷

8. 请求解析模块

   > 能够从`TCP`流中解析出`HTTP`请求行、请求头、请求体（当然针对日志浏览的请求，没有请求体），而且我们也只是实现了`GET`请求，能够正确提取出方法、`URL`（浏览器期待的文件或目录）、版本、头部

9. 响应生成模块

   > 根据从请求中解析出的`HTTP`的请求数据细节，动态生成并拼接出符合`HTTP`协议的响应，包括状态行、响应头、空行、响应体（在请求文件的时候，填充为文件内容）

10. 缓冲区动态扩容

    > 构造了一个`buffer`缓冲区模块，在应对大文件或长请求的时候支持自动扩容

11. 缓冲区的作用

    > 网络数据基于流，数据可能分次到达或发送，用缓冲区临时存储从`socket`中读取的数据，以及待发送的数据，尽量保证数据的完整性和高效处理
    >
    > 发送的时候，其实是规避了`TCP`粘包的问题

12. 静态日志文件服务

    > 在返回目录结构时，一开始以文件后缀进行了一遍过滤（`.log`、`.txt`、`.log.txt`），我后续取消了这个限制来使这项目更符合通用文件服务

13. `IO`多路复用的作用

    > 传统阻塞`IO`模型每个连接一个线程，资源消耗大，难以支撑高并发，`IO`多路复用允许单线程同时监听多个`socket`的`IO`事件

14. `Dispatcher`负责什么

    > 负责注册、监听、分发`socket`事件（新连接到达、数据可读可写）

15. `epoll`的处理流程

    > 事件注册：当新的`socket`连接建立之后，通过`epoll_ctl`注册到`epoll`实例，监听其读写事件
    >
    > 事件循环：主线程或工作线程调用`epoll_wait`等待事件发生
    >
    > 事件分发：一旦有事件发生，`epoll`返回活跃的`fd`列表，事件循环遍历这些`fd`，然后调用对应的回调函数进行处理（读取`HTTP`请求、发送响应）
    >
    > 高并发处理：由于`epoll`高效，单线程即可管理成千上万个连接，再加上线程池模型，每个线程都能独立高效处理大量连接
    >
    > 封装了三种`IO`多路复用机制（`select`、`poll`、`epoll`），通过统一的`Dispatcher`接口注册和监听`socket`事件。事件循环采用`epoll_wait`高效等待活跃的`fd`，将事件分发给对应的回调函数，实现了单线程高效管理成千上万个并发连接。
    >
    > 主线程：只负责`accept`新连接，不处理具体业务。
    > 工作线程：每个线程有自己的事件循环（`event loop`），用`epoll`等技术管理和处理分配给它的所有连接，当某个连接有事件（如可读/可写）时，`epoll`会通知线程，线程再去处理对应的连接和数据。。
    > 每个工作线程内部是“单线程高并发”，整个服务器是“多线程+每线程高并发”。

16. 

    